<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Wald tests of multiple-constraint null hypotheses â€¢ clubSandwich</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Wald tests of multiple-constraint null hypotheses">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">clubSandwich</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.5.11.9999</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/meta-analysis-with-CRVE.html">Meta-analysis with cluster-robust variance estimation</a></li>
    <li><a class="dropdown-item" href="../articles/panel-data-CRVE.html">Cluster-robust standard errors and hypothesis tests in panel data models</a></li>
    <li><a class="dropdown-item" href="../articles/Wald-tests-in-clubSandwich.html">Wald tests of multiple-constraint null hypotheses</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/jepusto/clubSandwich/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Wald tests of multiple-constraint null hypotheses</h1>
                        <h4 data-toc-skip class="author">James E.
Pustejovsky</h4>
            
            <h4 data-toc-skip class="date">2025-02-28</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/jepusto/clubSandwich/blob/main/vignettes/Wald-tests-in-clubSandwich.Rmd" class="external-link"><code>vignettes/Wald-tests-in-clubSandwich.Rmd</code></a></small>
      <div class="d-none name"><code>Wald-tests-in-clubSandwich.Rmd</code></div>
    </div>

    
    
<p>Version 0.5.0 of <code>clubSandwich</code> introduced a new syntax
for <code><a href="../reference/Wald_test.html">Wald_test()</a></code>, a function for conducting tests of
multiple-constraint hypotheses. In previous versions, this function was
poorly documented and, consequently, probably little used. This vignette
will demonstrate the new syntax.</p>
<p>For purposes of illustration, I will use the <code>STAR</code> data
(available in the <code>AER</code> package), which is drawn from a
randomized trial evaluating the effects of elementary school class size
on student achievement. The data consist of individual-level measures
for students in each of several dozen schools. For purposes of
illustration, I will look at effects on math performance in first grade.
Treatment conditions (the variable called <code>stark</code>) were
assigned at the classroom level, and consisted of either a) a
regular-size class, b) a small-size class, or c) a regular-size class
but with the addition of a teacherâ€™s aide. In all of what follows, I
will cluster standard errors by school in order to allow for
generalization to a super-population of schools.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="http://jepusto.github.io/clubSandwich/">clubSandwich</a></span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">STAR</span>, package <span class="op">=</span> <span class="st">"AER"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># clean up a few variables</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/levels.html" class="external-link">levels</a></span><span class="op">(</span><span class="va">STAR</span><span class="op">$</span><span class="va">stark</span><span class="op">)</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"aide"</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/levels.html" class="external-link">levels</a></span><span class="op">(</span><span class="va">STAR</span><span class="op">$</span><span class="va">schoolk</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"urban"</span></span>
<span><span class="va">STAR</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/subset.html" class="external-link">subset</a></span><span class="op">(</span><span class="va">STAR</span>, </span>
<span>               <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">schoolidk</span><span class="op">)</span>,</span>
<span>               select <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">schoolidk</span>, <span class="va">schoolk</span>, <span class="va">stark</span>, <span class="va">gender</span>, <span class="va">ethnicity</span>, <span class="va">math1</span>, <span class="va">lunchk</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">STAR</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      schoolidk  schoolk   stark gender ethnicity math1   lunchk</span></span>
<span><span class="co">## 1137        63    rural   small female      cauc   538 non-free</span></span>
<span><span class="co">## 1143        20 suburban   small female      afam   592 non-free</span></span>
<span><span class="co">## 1183        19    urban    aide   male      afam    NA     free</span></span>
<span><span class="co">## 1277        69    rural regular   male      cauc   584 non-free</span></span>
<span><span class="co">## 1292        79    rural   small   male      cauc   545     free</span></span>
<span><span class="co">## 1308         5    rural regular   male      cauc   553     free</span></span></code></pre>
<div class="section level2">
<h2 id="the-wald-test-function">The Wald test function<a class="anchor" aria-label="anchor" href="#the-wald-test-function"></a>
</h2>
<p>The <code><a href="../reference/Wald_test.html">Wald_test()</a></code> function can be used to conduct
hypothesis tests that involve multiple constraints on the regression
coefficients. Consider a linear model for an outcome
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">Y_{ij}</annotation></semantics></math>
regressed on a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>Ã—</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">1 \times p</annotation></semantics></math>
row vector of predictors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">\mathbf{x}_{ij}</annotation></semantics></math>
(which might include a constant intercept term):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>ğ±</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>ğ›ƒ</mi><mo>+</mo><msub><mi>Ïµ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">
Y_{ij} = \mathbf{x}_{ij} \boldsymbol\beta + \epsilon_{ij}
</annotation></semantics></math> The regression coefficient vector is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ›ƒ</mi><annotation encoding="application/x-tex">\boldsymbol\beta</annotation></semantics></math>.
In quite general terms, a set of constraints on the regression
coefficient vector can be expressed in terms of a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>Ã—</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">q \times p</annotation></semantics></math>
matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ‚</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>,
where each row of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ‚</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>
corresponds to one constraint. A joint null hypothesis is then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>:</mo><mi>ğ‚</mi><mi>ğ›ƒ</mi><mo>=</mo><mn>ğŸ</mn></mrow><annotation encoding="application/x-tex">H_0: \mathbf{C} \boldsymbol\beta = \mathbf{0}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>ğŸ</mn><annotation encoding="application/x-tex">\mathbf{0}</annotation></semantics></math>
is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>Ã—</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">q \times 1</annotation></semantics></math>
vector of zeros.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;In &lt;span class="citation"&gt;Pustejovsky &amp;amp; Tipton
(2018)&lt;/span&gt; we used a more general formulation of multiple-constraint
null hypotheses, expressed as
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;H&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi&gt;ğ‚&lt;/mi&gt;&lt;mi&gt;ğ›ƒ&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;ğ&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;H_0: \mathbf{C} \boldsymbol\beta = \mathbf{d}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
for some fixed
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;Ã—&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;q \times 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
vector
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mi&gt;ğ&lt;/mi&gt;&lt;annotation encoding="application/x-tex"&gt;\mathbf{d}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;.
In practice, itâ€™s often possible to modify the
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mi&gt;ğ‚&lt;/mi&gt;&lt;annotation encoding="application/x-tex"&gt;\mathbf{C}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
matrix so that
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mi&gt;ğ&lt;/mi&gt;&lt;annotation encoding="application/x-tex"&gt;\mathbf{d}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
can always be set to
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mn&gt;ğŸ&lt;/mn&gt;&lt;annotation encoding="application/x-tex"&gt;\mathbf{0}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;.&lt;/p&gt;'><sup>1</sup></a></p>
<p>Wald-type test are based on the test statistic
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ‚</mi><mover><mi>ğ›ƒ</mi><mo accent="true">Ì‚</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mi>â€²</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ‚</mi><msup><mi>ğ•</mi><mrow><mi>C</mi><mi>R</mi></mrow></msup><mi>ğ‚</mi><mi>â€²</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ‚</mi><mover><mi>ğ›ƒ</mi><mo accent="true">Ì‚</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
Q = \left(\mathbf{C}\boldsymbol{\hat\beta}\right)' \left(\mathbf{C} \mathbf{V}^{CR} \mathbf{C}'\right)^{-1} \left(\mathbf{C}\boldsymbol{\hat\beta}\right),
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>ğ›ƒ</mi><mo accent="true">Ì‚</mo></mover><annotation encoding="application/x-tex">\boldsymbol{\hat\beta}</annotation></semantics></math>
is the estimated regression coefficient vector and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ğ•</mi><mrow><mi>C</mi><mi>R</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{V}^{CR}</annotation></semantics></math>
is a cluster-robust variance matrix. If the number of clusters is
sufficiently large, then the distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
under the null hypothesis is approximately
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Ï‡</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>q</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\chi^2(q)</annotation></semantics></math>.
<span class="citation">Tipton &amp; Pustejovsky (2015)</span>
investigated a wide range of other approximations to the null
distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>,
many of which are included as options in <code><a href="../reference/Wald_test.html">Wald_test()</a></code>. Based
on a large simulation, they (â€¦erâ€¦weâ€¦) recommended a method called the
â€œapproximate Hotellingâ€™s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>T</mi><mn>2</mn></msup><annotation encoding="application/x-tex">T^2</annotation></semantics></math>-Zâ€
test, or â€œAHZ.â€ This test approximates the distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mi>/</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">Q / q</annotation></semantics></math>
by a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>T</mi><mn>2</mn></msup><annotation encoding="application/x-tex">T^2</annotation></semantics></math>
distribution, which is a multiple of an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
distribution, with numerator degrees of freedom
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>
and denominator degrees of freedom based on a generalization of the
Satterthwaite approximation.</p>
<p>The <code><a href="../reference/Wald_test.html">Wald_test()</a></code> function has three main arguments:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/args.html" class="external-link">args</a></span><span class="op">(</span><span class="va">Wald_test</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## function (obj, constraints, vcov, null_constant = 0, test = "HTZ", </span></span>
<span><span class="co">##     tidy = FALSE, ...) </span></span>
<span><span class="co">## NULL</span></span></code></pre>
<ul>
<li>The <code>obj</code> argument is used to specify the estimated
regression model on which to perform the test,</li>
<li>the <code>constraints</code> argument is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ‚</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>
matrix expressing the set of constraints to test, and</li>
<li>the <code>vcov</code> argument is a cluster-robust variance matrix,
which is used to construct the test statistic. (Alternately,
<code>vcov</code> can be the type of cluster-robust variance matrix to
construct, in which case it will be computed internally.)</li>
</ul>
<p>By default, <code><a href="../reference/Wald_test.html">Wald_test()</a></code> will use the HTZ small-sample
approximation. Other options are available (via the <code>test</code>
argument) but not recommended for routine use. The optional
<code>tidy</code> argument will be demonstrated below.</p>
<div class="section level3">
<h3 id="testing-treatment-effects">Testing treatment effects<a class="anchor" aria-label="anchor" href="#testing-treatment-effects"></a>
</h3>
<p>Returning to the STAR data, letâ€™s suppose we want to examine
differences in math performance across class sizes. This can be done
with a simple linear regression model, while clustering the standard
errors by <code>schoolidk</code>. The estimating equation is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">Math</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>Î²</mi><mn>0</mn></msub><mo>+</mo><msub><mi>Î²</mi><mn>1</mn></msub><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">small</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>Î²</mi><mn>2</mn></msub><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">aide</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">
\left(\text{Math}\right)_{ij} = \beta_0 + \beta_1 \left(\text{small}\right)_{ij} + \beta_2 \left(\text{aide}\right)_{ij} + e_{ij},
</annotation></semantics></math> which can be estimated in R as
follows:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lm_trt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">math1</span> <span class="op">~</span> <span class="va">stark</span>, data <span class="op">=</span> <span class="va">STAR</span><span class="op">)</span></span>
<span><span class="va">V_trt</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/vcovCR.html">vcovCR</a></span><span class="op">(</span><span class="va">lm_trt</span>, cluster <span class="op">=</span> <span class="va">STAR</span><span class="op">$</span><span class="va">schoolidk</span>, type <span class="op">=</span> <span class="st">"CR2"</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/coef_test.html">coef_test</a></span><span class="op">(</span><span class="va">lm_trt</span>, vcov <span class="op">=</span> <span class="va">V_trt</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Alternative hypothesis: two-sided </span></span>
<span><span class="co">##        Coef. Estimate   SE Null value  t-stat d.f. (Satt) p-val (Satt) Sig.</span></span>
<span><span class="co">##  (Intercept)  531.727 2.78          0 191.506        59.9       &lt;0.001  ***</span></span>
<span><span class="co">##   starksmall    9.469 2.30          0   4.114        65.6       &lt;0.001  ***</span></span>
<span><span class="co">##    starkaide   -0.483 1.86          0  -0.259        65.6        0.796</span></span></code></pre>
<p>In this estimating equation, the coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î²</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\beta_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î²</mi><mn>2</mn></msub><annotation encoding="application/x-tex">\beta_2</annotation></semantics></math>
represent treatment effects, or differences in average math scores
relative to the reference level of <code>stark</code>, which in this
case is a regular-size class. The t-statistics and p-values reported by
<code>coef_test</code> are separate tests of the null hypotheses that
each of these coefficients are equal to zero, meaning that there is no
difference between the specified treatment condition and the reference
level. We might want to instead test the <em>joint</em> null hypothesis
that there are no differences among <em>any</em> of the conditions. This
null can be expressed by a set of multiple constraints on the
parameters:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î²</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\beta_1 = 0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î²</mi><mn>2</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\beta_2 = 0</annotation></semantics></math>.</p>
<p>To test the null hypothesis that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î²</mi><mn>1</mn></msub><mo>=</mo><msub><mi>Î²</mi><mn>2</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\beta_1 = \beta_2 = 0</annotation></semantics></math>
based on the treatment effects model specification, we can use:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">C_trt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span>, <span class="fl">2</span>, <span class="fl">3</span><span class="op">)</span></span>
<span><span class="va">C_trt</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,]    0    1    0</span></span>
<span><span class="co">## [2,]    0    0    1</span></span></code></pre>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span><span class="va">lm_trt</span>, constraints <span class="op">=</span> <span class="va">C_trt</span>, vcov <span class="op">=</span> <span class="va">V_trt</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  test Fstat df_num df_denom  p_val sig</span></span>
<span><span class="co">##   HTZ  10.2      2     65.3 &lt;0.001 ***</span></span></code></pre>
<p>The result includes details about the form of <code>test</code>
computed, the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-statistic,
the numerator and denominator degrees of freedom used to compute the
reference distribution, and the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-value
corresponding to the specified null hypothesis. In this example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>0.000141</mn></mrow><annotation encoding="application/x-tex">p = 0.000141</annotation></semantics></math>,
so we can rule out the null hypothesis that there are no differences in
math performance across conditions.</p>
<p>The representation of null hypotheses as arbitrary constraint
matrices is useful for developing theory about how to test such
hypotheses, but it is not all that helpful for actually running
testsâ€”constructing constraint matrices â€œby handâ€ is just too cumbersome
of an exercise. Moreover,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ‚</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>
matrices typically follow one of a small number of patterns. Two common
use cases are a) constraining a set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">q &gt; 1</annotation></semantics></math>
parameters to all be equal to zero and b) constraining a set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">q + 1</annotation></semantics></math>
parameters to be equal to a common value. The <code>clubSandwich</code>
package now includes a set of helper functions to create constraint
matrices for these common use cases.</p>
</div>
<div class="section level3">
<h3 id="constrain_zero">
<code>constrain_zero()</code><a class="anchor" aria-label="anchor" href="#constrain_zero"></a>
</h3>
<p>To constrain a set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>
regression coefficients to all be equal to zero, the simplest form of
the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ‚</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>
matrix would consist of a set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>
rows, where a single entry in each row would be equal to 1 and the
remaining entries would all be zero. For the <code>lm_trt</code> model,
the C matrix would look like this:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ‚</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathbf{C} = \left[\begin{array}{ccc} 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right],
</annotation></semantics></math> so that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ‚</mi><mi>ğ›ƒ</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>Î²</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>Î²</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>Î²</mi><mn>2</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>Î²</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>Î²</mi><mn>2</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathbf{C}\boldsymbol\beta = \left[\begin{array}{ccc} 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right] \left[\begin{array}{c} \beta_0 \\ \beta_1 \\ \beta_2 \end{array} \right] = \left[\begin{array}{c} \beta_1 \\ \beta_2 \end{array} \right],
</annotation></semantics></math> which is set equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c} 0 \\ 0 \end{array} \right]</annotation></semantics></math>.</p>
<p>The <code><a href="../reference/constraint_matrices.html">constrain_zero()</a></code> function will create matrices like
this automatically. The function takes two main arguments:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/args.html" class="external-link">args</a></span><span class="op">(</span><span class="va">constrain_zero</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## function (constraints, coefs, reg_ex = FALSE) </span></span>
<span><span class="co">## NULL</span></span></code></pre>
<ul>
<li>The <code>constraints</code> argument is used to specify
<em>which</em> coefficients in a regression model to set equal to
zero.</li>
<li>The <code>coefs</code> argument is the set of estimated regression
coefficients, for which to calculate the constraints.</li>
</ul>
<p>Constraints can be specified by position index, by name, or via a
regular expression. To test the joint null hypothesis that average math
performance is equal across the three treatment conditions, we need to
constrain the second and third coefficients to zero:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/constraint_matrices.html">constrain_zero</a></span><span class="op">(</span><span class="fl">2</span><span class="op">:</span><span class="fl">3</span>, coefs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">lm_trt</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,]    0    1    0</span></span>
<span><span class="co">## [2,]    0    0    1</span></span></code></pre>
<p>Or equivalently:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/constraint_matrices.html">constrain_zero</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"starksmall"</span>,<span class="st">"starkaide"</span><span class="op">)</span>, coefs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">lm_trt</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,]    0    1    0</span></span>
<span><span class="co">## [2,]    0    0    1</span></span></code></pre>
<p>or</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/constraint_matrices.html">constrain_zero</a></span><span class="op">(</span><span class="st">"^stark"</span>, coefs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">lm_trt</span><span class="op">)</span>, reg_ex <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,]    0    1    0</span></span>
<span><span class="co">## [2,]    0    0    1</span></span></code></pre>
<p>Note that if <code>constraints</code> is a regular expression, then
the <code>reg_ex</code> argument needs to be set to
<code>TRUE</code>.</p>
<p>The result of <code><a href="../reference/constraint_matrices.html">constrain_zero()</a></code> can then be fed into the
<code><a href="../reference/Wald_test.html">Wald_test()</a></code> function:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">C_trt</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/constraint_matrices.html">constrain_zero</a></span><span class="op">(</span><span class="fl">2</span><span class="op">:</span><span class="fl">3</span>, coefs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">lm_trt</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span><span class="va">lm_trt</span>, constraints <span class="op">=</span> <span class="va">C_trt</span>, vcov <span class="op">=</span> <span class="va">V_trt</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  test Fstat df_num df_denom  p_val sig</span></span>
<span><span class="co">##   HTZ  10.2      2     65.3 &lt;0.001 ***</span></span></code></pre>
<p>To reduce redundancy in the syntax, we can also omit the
<code>coefs</code> argument to <code>constrain_zero</code>, so long as
we call it inside of <code>Wald_test</code><a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;How does this work? If we omit the &lt;code&gt;coefs&lt;/code&gt;
argument, &lt;code&gt;&lt;a href="../reference/constraint_matrices.html"&gt;constrain_zero()&lt;/a&gt;&lt;/code&gt; acts as a functional, by
returning a function equivalent to
&lt;code&gt;function(coefs) constrain_zero(constraints, coefs = coefs)&lt;/code&gt;.
If this function is fed into the &lt;code&gt;constraints&lt;/code&gt; argument of
&lt;code&gt;&lt;a href="../reference/Wald_test.html"&gt;Wald_test()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href="../reference/Wald_test.html"&gt;Wald_test()&lt;/a&gt;&lt;/code&gt; recognizes that it is
a function and evaluates the function with &lt;code&gt;coef(obj)&lt;/code&gt;. Itâ€™s
a kinda-sorta hacky substitute for lazy evaluation. If you have
suggestions for how to do this more elegantly, please send them my
way.&lt;/p&gt;'><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span><span class="va">lm_trt</span>, constraints <span class="op">=</span> <span class="fu"><a href="../reference/constraint_matrices.html">constrain_zero</a></span><span class="op">(</span><span class="fl">2</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span>, vcov <span class="op">=</span> <span class="va">V_trt</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  test Fstat df_num df_denom  p_val sig</span></span>
<span><span class="co">##   HTZ  10.2      2     65.3 &lt;0.001 ***</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="constrain_equal">
<code>constrain_equal()</code><a class="anchor" aria-label="anchor" href="#constrain_equal"></a>
</h3>
<p>Another common type of constraints involve setting a set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">q + 1</annotation></semantics></math>
regression coefficients to be all equal to a common (but unknown) value
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">q + 1</annotation></semantics></math>
because it takes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>
constraints to do this). There are many equivalent ways to express such
a set of constraints in terms of a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ‚</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>
matrix. One fairly simple form consists of a set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>
rows, where the entry corresponding to one of the coefficients of
interest is equal to -1 and the entry corresponding to another
coefficient of interest is equal to 1.</p>
<p>To see how this works, letâ€™s look at a different way of
parameterizing our simple model for the STAR data, by using separate
intercepts for each treatment condition. The estimating equation would
then be
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">Math</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>Î²</mi><mn>0</mn></msub><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">regular</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>Î²</mi><mn>1</mn></msub><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">small</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>Î²</mi><mn>2</mn></msub><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">aide</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
\left(\text{Math}\right)_{ij} = \beta_0 \left(\text{regular}\right)_{ij} + \beta_1 \left(\text{small}\right)_{ij} + \beta_2 \left(\text{aide}\right)_{ij} + e_{ij}.
</annotation></semantics></math> This model can be estimated in R by
dropping the intercept term:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lm_sep</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">math1</span> <span class="op">~</span> <span class="fl">0</span> <span class="op">+</span> <span class="va">stark</span>, data <span class="op">=</span> <span class="va">STAR</span><span class="op">)</span></span>
<span><span class="va">V_sep</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/vcovCR.html">vcovCR</a></span><span class="op">(</span><span class="va">lm_sep</span>, cluster <span class="op">=</span> <span class="va">STAR</span><span class="op">$</span><span class="va">schoolidk</span>, type <span class="op">=</span> <span class="st">"CR2"</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/coef_test.html">coef_test</a></span><span class="op">(</span><span class="va">lm_sep</span>, vcov <span class="op">=</span> <span class="va">V_sep</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Alternative hypothesis: two-sided </span></span>
<span><span class="co">##         Coef. Estimate   SE Null value t-stat d.f. (Satt) p-val (Satt) Sig.</span></span>
<span><span class="co">##  starkregular      532 2.78          0    192        59.9       &lt;0.001  ***</span></span>
<span><span class="co">##    starksmall      541 2.89          0    187        65.0       &lt;0.001  ***</span></span>
<span><span class="co">##     starkaide      531 2.72          0    195        64.3       &lt;0.001  ***</span></span></code></pre>
<p>In this parameterization, the coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î²</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\beta_0</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î²</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\beta_1</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î²</mi><mn>2</mn></msub><annotation encoding="application/x-tex">\beta_2</annotation></semantics></math>
represent the average math performance levels of students in each of the
treatment conditions. The t-tests and p-values now have a very different
interpretation because they pertain to the null hypothesis that the
average performance level for a given condition is equal to zero. With
this separate-intercepts model, the joint null hypothesis that
performance levels are equal across conditions amounts to constraining
the intercepts to be equal to each other:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î²</mi><mn>0</mn></msub><mo>=</mo><msub><mi>Î²</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\beta_0 = \beta_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î²</mi><mn>0</mn></msub><mo>=</mo><msub><mi>Î²</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\beta_0 = \beta_2</annotation></semantics></math>
(note that we donâ€™t need the constraint
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î²</mi><mn>1</mn></msub><mo>=</mo><msub><mi>Î²</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\beta_1 = \beta_2</annotation></semantics></math>
because it is implied by the first two).</p>
<p>For the <code>lm_sep</code> model, which has separate intercepts
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î²</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\beta_0</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î²</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\beta_1</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î²</mi><mn>2</mn></msub><annotation encoding="application/x-tex">\beta_2</annotation></semantics></math>,
the C matrix would look like this:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ‚</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mo>âˆ’</mo><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mo>âˆ’</mo><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathbf{C} = \left[\begin{array}{ccc} -1 &amp; 1 &amp; 0 \\ -1 &amp; 0 &amp; 1 \end{array} \right],
</annotation></semantics></math> so that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ‚</mi><mi>ğ›ƒ</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mo>âˆ’</mo><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mo>âˆ’</mo><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>Î²</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>Î²</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>Î²</mi><mn>2</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>Î²</mi><mn>1</mn></msub><mo>âˆ’</mo><msub><mi>Î²</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>Î²</mi><mn>2</mn></msub><mo>âˆ’</mo><msub><mi>Î²</mi><mn>0</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathbf{C}\boldsymbol\beta = \left[\begin{array}{ccc} -1 &amp; 1 &amp; 0 \\ -1 &amp; 0 &amp; 1 \end{array} \right] \left[\begin{array}{c} \beta_0 \\ \beta_1 \\ \beta_2 \end{array} \right] = \left[\begin{array}{c} \beta_1 - \beta_0 \\ \beta_2 - \beta_0 \end{array} \right],
</annotation></semantics></math> which is set equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c} 0 \\ 0 \end{array} \right]</annotation></semantics></math>.</p>
<p>The <code><a href="../reference/constraint_matrices.html">constrain_equal()</a></code> function will create matrices like
this automatically, given a set of coefficients to constrain. The syntax
is identical to <code><a href="../reference/constraint_matrices.html">constrain_zero()</a></code>:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/args.html" class="external-link">args</a></span><span class="op">(</span><span class="va">constrain_equal</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## function (constraints, coefs, reg_ex = FALSE) </span></span>
<span><span class="co">## NULL</span></span></code></pre>
<p>To test the joint null hypothesis that average math performance is
equal across the three treatment conditions, we can constrain all three
coefficients of <code>lm_sep</code> to be equal:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/constraint_matrices.html">constrain_equal</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>, coefs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">lm_sep</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,]   -1    1    0</span></span>
<span><span class="co">## [2,]   -1    0    1</span></span></code></pre>
<p>Or equivalently:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/constraint_matrices.html">constrain_equal</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"starkregular"</span>,<span class="st">"starksmall"</span>,<span class="st">"starkaide"</span><span class="op">)</span>, coefs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">lm_sep</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,]   -1    1    0</span></span>
<span><span class="co">## [2,]   -1    0    1</span></span></code></pre>
<p>or</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/constraint_matrices.html">constrain_equal</a></span><span class="op">(</span><span class="st">"^stark"</span>, coefs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">lm_sep</span><span class="op">)</span>, reg_ex <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,]   -1    1    0</span></span>
<span><span class="co">## [2,]   -1    0    1</span></span></code></pre>
<p>Just as with <code>constrain_zero</code>, if <code>constraints</code>
is a regular expression, then the <code>reg_ex</code> argument needs to
be set to <code>TRUE</code>.</p>
<p>This constraint matrix can then be fed into
<code><a href="../reference/Wald_test.html">Wald_test()</a></code>:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">C_sep</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/constraint_matrices.html">constrain_equal</a></span><span class="op">(</span><span class="st">"^stark"</span>, coefs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">lm_sep</span><span class="op">)</span>, reg_ex <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span><span class="va">lm_sep</span>, constraints <span class="op">=</span> <span class="va">C_sep</span>, vcov <span class="op">=</span> <span class="va">V_sep</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  test Fstat df_num df_denom  p_val sig</span></span>
<span><span class="co">##   HTZ  10.2      2     65.3 &lt;0.001 ***</span></span></code></pre>
<p>or equivalently:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span><span class="va">lm_sep</span>, constraints <span class="op">=</span> <span class="fu"><a href="../reference/constraint_matrices.html">constrain_equal</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span>, vcov <span class="op">=</span> <span class="va">V_sep</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  test Fstat df_num df_denom  p_val sig</span></span>
<span><span class="co">##   HTZ  10.2      2     65.3 &lt;0.001 ***</span></span></code></pre>
<p>Note that these test results are exactly equal to the tests based on
<code>lm_trt</code> with <code><a href="../reference/constraint_matrices.html">constrain_zero()</a></code>. Theyâ€™re
algebraically equivalentâ€”just different ways of parameterizing the same
model and constraints.</p>
</div>
</div>
<div class="section level2">
<h2 id="testing-an-interaction">Testing an interaction<a class="anchor" aria-label="anchor" href="#testing-an-interaction"></a>
</h2>
<p>Letâ€™s now consider how these functions can be applied in a more
complex model. Suppose that we are interested in understanding whether
the effect of being in a small class is consistent across schools in
different areas, where areas are categorized as urban, suburban, or
rural. To answer this question, we need to test for an interaction
between urbanicity and treatment condition. One estimating equation that
would let us examine this question is:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">Math</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>Î²</mi><mn>0</mn></msub><mo>+</mo><msub><mi>Î²</mi><mn>1</mn></msub><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">suburban</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>Î²</mi><mn>2</mn></msub><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">rural</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mspace width="1.0em"></mspace><mo>+</mo><msub><mi>Î²</mi><mn>3</mn></msub><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">small</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>Î²</mi><mn>4</mn></msub><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">aide</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mo>+</mo><msub><mi>Î²</mi><mn>5</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">small</mtext><mo stretchy="true" form="postfix">)</mo></mrow><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">suburban</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>Î²</mi><mn>6</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">aide</mtext><mo stretchy="true" form="postfix">)</mo></mrow><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">suburban</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mo>+</mo><msub><mi>Î²</mi><mn>7</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">small</mtext><mo stretchy="true" form="postfix">)</mo></mrow><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">rural</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>Î²</mi><mn>8</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">aide</mtext><mo stretchy="true" form="postfix">)</mo></mrow><msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">rural</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mo>+</mo><msub><mi>ğ±</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>ğ›„</mi><mo>+</mo><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\left(\text{Math}\right)_{ij} &amp;= \beta_0 + \beta_1 \left(\text{suburban}\right)_{ij} + \beta_2 \left(\text{rural}\right)_{ij} \\
&amp; \quad + \beta_3 \left(\text{small}\right)_{ij} + \beta_4 \left(\text{aide}\right)_{ij} \\
&amp; \quad\quad + \beta_5 \left(\text{small}\right)(\text{suburban})_{ij} + \beta_6 \left(\text{aide}\right)(\text{suburban})_{ij} \\
&amp; \quad\quad\quad + \beta_{7} \left(\text{small}\right)(\text{rural})_{ij} + \beta_{8} \left(\text{aide}\right)(\text{rural})_{ij} \\
&amp; \quad\quad\quad\quad + \mathbf{x}_{ij} \boldsymbol\gamma  + e_{ij},
\end{aligned}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">\mathbf{x}_{ij}</annotation></semantics></math>
is a row vector of student characteristics, included just to make the
regression look fancier. In this specification,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î²</mi><mn>3</mn></msub><annotation encoding="application/x-tex">\beta_3</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î²</mi><mn>4</mn></msub><annotation encoding="application/x-tex">\beta_4</annotation></semantics></math>
represent the effects of being in a small class or aide class, compared
to being in a regular class, but <em>only for the reference level of
urbanicity</em>â€”in this case, urban schools. The coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î²</mi><mn>5</mn></msub><mo>,</mo><msub><mi>Î²</mi><mn>6</mn></msub><mo>,</mo><msub><mi>Î²</mi><mn>7</mn></msub><mo>,</mo><msub><mi>Î²</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">\beta_5, \beta_6, \beta_7, \beta_8</annotation></semantics></math>
all represent <em>interactions</em> between treatment condition and
urbanicity. Hereâ€™s the model, estimated in R:</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lm_urbanicity</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">math1</span> <span class="op">~</span> <span class="va">schoolk</span> <span class="op">*</span> <span class="va">stark</span> <span class="op">+</span> <span class="va">gender</span> <span class="op">+</span> <span class="va">ethnicity</span> <span class="op">+</span> <span class="va">lunchk</span>, data <span class="op">=</span> <span class="va">STAR</span><span class="op">)</span></span>
<span><span class="va">V_urbanicity</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/vcovCR.html">vcovCR</a></span><span class="op">(</span><span class="va">lm_urbanicity</span>, cluster <span class="op">=</span> <span class="va">STAR</span><span class="op">$</span><span class="va">schoolidk</span>, type <span class="op">=</span> <span class="st">"CR2"</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/coef_test.html">coef_test</a></span><span class="op">(</span><span class="va">lm_urbanicity</span>, vcov <span class="op">=</span> <span class="va">V_urbanicity</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Alternative hypothesis: two-sided </span></span>
<span><span class="co">##                       Coef. Estimate    SE Null value  t-stat d.f. (Satt)</span></span>
<span><span class="co">##                 (Intercept)   542.62  5.91          0 91.8599       21.70</span></span>
<span><span class="co">##             schoolksuburban     2.77  6.76          0  0.4100       28.35</span></span>
<span><span class="co">##                schoolkrural     1.03  6.38          0  0.1616       30.74</span></span>
<span><span class="co">##                  starksmall     9.42  4.56          0  2.0649       17.10</span></span>
<span><span class="co">##                   starkaide    -4.27  2.17          0 -1.9631       16.73</span></span>
<span><span class="co">##                genderfemale     2.14  1.20          0  1.7773       67.14</span></span>
<span><span class="co">##               ethnicityafam   -16.79  4.19          0 -4.0026       34.94</span></span>
<span><span class="co">##              ethnicityasian    13.19 11.02          0  1.1963        6.23</span></span>
<span><span class="co">##           ethnicityhispanic    39.23 20.62          0  1.9028        1.01</span></span>
<span><span class="co">##              ethnicityother     8.86 18.78          0  0.4720        3.02</span></span>
<span><span class="co">##                  lunchkfree   -19.37  2.04          0 -9.4848       57.38</span></span>
<span><span class="co">##  schoolksuburban:starksmall     3.03  6.39          0  0.4746       28.94</span></span>
<span><span class="co">##     schoolkrural:starksmall    -0.31  5.58          0 -0.0555       34.04</span></span>
<span><span class="co">##   schoolksuburban:starkaide     5.10  3.72          0  1.3711       28.64</span></span>
<span><span class="co">##      schoolkrural:starkaide     8.16  3.16          0  2.5857       34.30</span></span>
<span><span class="co">##  p-val (Satt) Sig.</span></span>
<span><span class="co">##        &lt;0.001  ***</span></span>
<span><span class="co">##        0.6849     </span></span>
<span><span class="co">##        0.8727     </span></span>
<span><span class="co">##        0.0544    .</span></span>
<span><span class="co">##        0.0665    .</span></span>
<span><span class="co">##        0.0800    .</span></span>
<span><span class="co">##        &lt;0.001  ***</span></span>
<span><span class="co">##        0.2751     </span></span>
<span><span class="co">##        0.3067     </span></span>
<span><span class="co">##        0.6690     </span></span>
<span><span class="co">##        &lt;0.001  ***</span></span>
<span><span class="co">##        0.6386     </span></span>
<span><span class="co">##        0.9560     </span></span>
<span><span class="co">##        0.1810     </span></span>
<span><span class="co">##        0.0141    *</span></span></code></pre>
<p>With this specification, there are several different null hypotheses
that we might want to test. For one, perhaps we want to see if there is
<em>any</em> variation in treatment effects across different levels of
urbanicity. This can be expressed in the null hypothesis that all four
interaction terms are zero, or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mrow><mn>0</mn><mi>A</mi></mrow></msub><mo>:</mo><msub><mi>Î²</mi><mn>5</mn></msub><mo>=</mo><msub><mi>Î²</mi><mn>6</mn></msub><mo>=</mo><msub><mi>Î²</mi><mn>7</mn></msub><mo>=</mo><msub><mi>Î²</mi><mn>8</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H_{0A}: \beta_5 = \beta_6 = \beta_7 = \beta_8 = 0</annotation></semantics></math>.
With Wald test:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span><span class="va">lm_urbanicity</span>, </span>
<span>          constraints <span class="op">=</span> <span class="fu"><a href="../reference/constraint_matrices.html">constrain_zero</a></span><span class="op">(</span><span class="st">"schoolk.+:stark"</span>, reg_ex <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>          vcov <span class="op">=</span> <span class="va">V_urbanicity</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  test Fstat df_num df_denom p_val sig</span></span>
<span><span class="co">##   HTZ  1.96      4     37.5 0.121</span></span></code></pre>
<p>Another possibility is that we might want to focus on variation in
the effect of being in a small class or regular class, while ignoring
whatever is going on in the aide class condition. Here, the null
hypothesis would be simply
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mrow><mn>0</mn><mi>B</mi></mrow></msub><mo>:</mo><msub><mi>Î²</mi><mn>5</mn></msub><mo>=</mo><msub><mi>Î²</mi><mn>6</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H_{0B}: \beta_5 = \beta_6 = 0</annotation></semantics></math>,
tested as:</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span><span class="va">lm_urbanicity</span>, </span>
<span>          constraints <span class="op">=</span> <span class="fu"><a href="../reference/constraint_matrices.html">constrain_zero</a></span><span class="op">(</span><span class="st">"schoolk.+:starksmall"</span>, reg_ex <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>          vcov <span class="op">=</span> <span class="va">V_urbanicity</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  test Fstat df_num df_denom p_val sig</span></span>
<span><span class="co">##   HTZ 0.189      2     34.5 0.828</span></span></code></pre>
<div class="section level3">
<h3 id="lists-of-constraints">Lists of constraints<a class="anchor" aria-label="anchor" href="#lists-of-constraints"></a>
</h3>
<p>In models like the urbanicity-by-treatment interaction specification,
we may need to run multiple tests on the same estimating equation. This
can be accomplished with <code>Wald_test</code> by providing a
<em>list</em> of constraints to the <code>constraints</code> argument.
For example, we could test the hypotheses described above by creating a
list of several constraint matrices and then passing it to
<code>Wald_test</code>:</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">C_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>  `Any interaction` <span class="op">=</span> <span class="fu"><a href="../reference/constraint_matrices.html">constrain_zero</a></span><span class="op">(</span><span class="st">"schoolk.+:stark"</span>, </span>
<span>                                     <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">lm_urbanicity</span><span class="op">)</span>, reg_ex <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  `Small vs regular` <span class="op">=</span> <span class="fu"><a href="../reference/constraint_matrices.html">constrain_zero</a></span><span class="op">(</span><span class="st">"schoolk.+:starksmall"</span>, </span>
<span>                                      <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">lm_urbanicity</span><span class="op">)</span>, reg_ex <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span><span class="va">lm_urbanicity</span>, </span>
<span>          constraints <span class="op">=</span> <span class="va">C_list</span>,</span>
<span>          vcov <span class="op">=</span> <span class="va">V_urbanicity</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## $`Any interaction`</span></span>
<span><span class="co">##  test Fstat df_num df_denom p_val sig</span></span>
<span><span class="co">##   HTZ  1.96      4     37.5 0.121    </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Small vs regular`</span></span>
<span><span class="co">##  test Fstat df_num df_denom p_val sig</span></span>
<span><span class="co">##   HTZ 0.189      2     34.5 0.828</span></span></code></pre>
<p>Setting the option <code>tidy = TRUE</code> will arrange the output
of all the tests into a single data frame:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span><span class="va">lm_urbanicity</span>, </span>
<span>          constraints <span class="op">=</span> <span class="va">C_list</span>,</span>
<span>          vcov <span class="op">=</span> <span class="va">V_urbanicity</span>, </span>
<span>          tidy <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##        hypothesis test Fstat df_num df_denom p_val sig</span></span>
<span><span class="co">##   Any interaction  HTZ 1.960      4     37.5 0.121    </span></span>
<span><span class="co">##  Small vs regular  HTZ 0.189      2     34.5 0.828</span></span></code></pre>
<p>The list of constraints can also be created inside
<code>Wald_test</code>, so that the <code>coefs</code> argument can be
omitted from <code><a href="../reference/constraint_matrices.html">constrain_zero()</a></code>:</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span></span>
<span>  <span class="va">lm_urbanicity</span>, </span>
<span>  constraints <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>    `Any interaction` <span class="op">=</span> <span class="fu"><a href="../reference/constraint_matrices.html">constrain_zero</a></span><span class="op">(</span><span class="st">"schoolk.+:stark"</span>, reg_ex <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>    `Small vs regular` <span class="op">=</span> <span class="fu"><a href="../reference/constraint_matrices.html">constrain_zero</a></span><span class="op">(</span><span class="st">"schoolk.+:starksmall"</span>, reg_ex <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span>  <span class="op">)</span>,</span>
<span>  vcov <span class="op">=</span> <span class="va">V_urbanicity</span>, </span>
<span>  tidy <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##        hypothesis test Fstat df_num df_denom p_val sig</span></span>
<span><span class="co">##   Any interaction  HTZ 1.960      4     37.5 0.121    </span></span>
<span><span class="co">##  Small vs regular  HTZ 0.189      2     34.5 0.828</span></span></code></pre>
</div>
</div>
<div class="section level2">
<h2 id="pairwise-t-tests">Pairwise t-tests<a class="anchor" aria-label="anchor" href="#pairwise-t-tests"></a>
</h2>
<p>The <code>clubSandwich</code> package also provides a further
convenience function, <code><a href="../reference/constraint_matrices.html">constrain_pairwise()</a></code> that can be used
in combination with <code><a href="../reference/Wald_test.html">Wald_test()</a></code> to conduct pairwise
comparisons among a set of regression coefficients. This function
differs from the other two <code>constrain_*()</code> functions because
it returns a <em>list</em> of constraint matrices, each of which
corresponds to a single linear combination of covariates. Specifically,
the <code><a href="../reference/constraint_matrices.html">constrain_pairwise()</a></code> function provides a list of
constraints that represent the differences between every possible pair
among a specified set of coefficients. The syntax is very similar to the
other <code>constrain_*()</code> functions.</p>
<p>To demonstrate, consider the separate-intercepts specification of the
simpler regression model:</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/coef_test.html">coef_test</a></span><span class="op">(</span><span class="va">lm_sep</span>, vcov <span class="op">=</span> <span class="va">V_sep</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Alternative hypothesis: two-sided </span></span>
<span><span class="co">##         Coef. Estimate   SE Null value t-stat d.f. (Satt) p-val (Satt) Sig.</span></span>
<span><span class="co">##  starkregular      532 2.78          0    192        59.9       &lt;0.001  ***</span></span>
<span><span class="co">##    starksmall      541 2.89          0    187        65.0       &lt;0.001  ***</span></span>
<span><span class="co">##     starkaide      531 2.72          0    195        64.3       &lt;0.001  ***</span></span></code></pre>
<p>This specification is nice because it lets us simply read off the
average outcomes for each group. However, we will naturally also want to
know about whether there are differences between the groups, so weâ€™ll
want to compare the small-class condition to the regular-size class
condition, the aide condition to the regular-size class condition, and
the small-class condition to the aide condition. Thus, weâ€™ll want
comparisons among all three coefficients:</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">C_pairs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/constraint_matrices.html">constrain_pairwise</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>, coefs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">lm_sep</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">C_pairs</span></span></code></pre></div>
<pre><code><span><span class="co">## $`starksmall - starkregular`</span></span>
<span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,]   -1    1    0</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`starkaide - starkregular`</span></span>
<span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,]   -1    0    1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`starkaide - starksmall`</span></span>
<span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,]    0   -1    1</span></span></code></pre>
<p>Feeding these constraints into <code><a href="../reference/Wald_test.html">Wald_test()</a></code> gives us
significance tests for each pair:</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span><span class="va">lm_sep</span>, constraints <span class="op">=</span> <span class="va">C_pairs</span>, vcov <span class="op">=</span> <span class="va">V_sep</span>, tidy <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##                 hypothesis test   Fstat df_num df_denom  p_val sig</span></span>
<span><span class="co">##  starksmall - starkregular  HTZ 16.9238      1     65.6 &lt;0.001 ***</span></span>
<span><span class="co">##   starkaide - starkregular  HTZ  0.0673      1     65.6  0.796    </span></span>
<span><span class="co">##     starkaide - starksmall  HTZ 17.8137      1     66.9 &lt;0.001 ***</span></span></code></pre>
<p>The first two of these tests are equivalent to the tests of the
treatment effect coefficients in the other parameterization of the
model. Indeed, the denominator degrees of freedom are identical to the
results of <code>coef_test(lm_trt, vcov = V_trt)</code>; the
<code>Fstat</code>s here are equal to the squared t-statistics from the
first model:</p>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">t_stats</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coef_test.html">coef_test</a></span><span class="op">(</span><span class="va">lm_trt</span>, vcov <span class="op">=</span> <span class="va">V_trt</span><span class="op">)</span><span class="op">$</span><span class="va">tstat</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span></span>
<span><span class="va">F_stats</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span><span class="va">lm_sep</span>, constraints <span class="op">=</span> <span class="va">C_pairs</span>, vcov <span class="op">=</span> <span class="va">V_sep</span>, tidy <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">$</span><span class="va">Fstat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/all.equal-methods.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">t_stats</span><span class="op">^</span><span class="fl">2</span>, <span class="va">F_stats</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] TRUE</span></span></code></pre>
<p>It is important to note that the p-values from the pairwise
comparisons are <em>not</em> corrected for multiplicity.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;Options to include multiplicity corrections (Bonferroni,
Holm, Benjamini-Hochberg, etc.) might be included in a &lt;a href="https://github.com/jepusto/clubSandwich/issues/33" class="external-link"&gt;future
release&lt;/a&gt;. Reach out if this is of interest to you.&lt;/p&gt;'><sup>3</sup></a> For now, please
correct-your-own using <code><a href="https://rdrr.io/r/stats/p.adjust.html" class="external-link">p.adjust()</a></code> or your preferred
method.</p>
<p>Pairwise comparisons might also be of use in the model with
treatment-by-urbanicity interactions. Hereâ€™s the model results
again:</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/coef_test.html">coef_test</a></span><span class="op">(</span><span class="va">lm_urbanicity</span>, vcov <span class="op">=</span> <span class="va">V_urbanicity</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Alternative hypothesis: two-sided </span></span>
<span><span class="co">##                       Coef. Estimate    SE Null value  t-stat d.f. (Satt)</span></span>
<span><span class="co">##                 (Intercept)   542.62  5.91          0 91.8599       21.70</span></span>
<span><span class="co">##             schoolksuburban     2.77  6.76          0  0.4100       28.35</span></span>
<span><span class="co">##                schoolkrural     1.03  6.38          0  0.1616       30.74</span></span>
<span><span class="co">##                  starksmall     9.42  4.56          0  2.0649       17.10</span></span>
<span><span class="co">##                   starkaide    -4.27  2.17          0 -1.9631       16.73</span></span>
<span><span class="co">##                genderfemale     2.14  1.20          0  1.7773       67.14</span></span>
<span><span class="co">##               ethnicityafam   -16.79  4.19          0 -4.0026       34.94</span></span>
<span><span class="co">##              ethnicityasian    13.19 11.02          0  1.1963        6.23</span></span>
<span><span class="co">##           ethnicityhispanic    39.23 20.62          0  1.9028        1.01</span></span>
<span><span class="co">##              ethnicityother     8.86 18.78          0  0.4720        3.02</span></span>
<span><span class="co">##                  lunchkfree   -19.37  2.04          0 -9.4848       57.38</span></span>
<span><span class="co">##  schoolksuburban:starksmall     3.03  6.39          0  0.4746       28.94</span></span>
<span><span class="co">##     schoolkrural:starksmall    -0.31  5.58          0 -0.0555       34.04</span></span>
<span><span class="co">##   schoolksuburban:starkaide     5.10  3.72          0  1.3711       28.64</span></span>
<span><span class="co">##      schoolkrural:starkaide     8.16  3.16          0  2.5857       34.30</span></span>
<span><span class="co">##  p-val (Satt) Sig.</span></span>
<span><span class="co">##        &lt;0.001  ***</span></span>
<span><span class="co">##        0.6849     </span></span>
<span><span class="co">##        0.8727     </span></span>
<span><span class="co">##        0.0544    .</span></span>
<span><span class="co">##        0.0665    .</span></span>
<span><span class="co">##        0.0800    .</span></span>
<span><span class="co">##        &lt;0.001  ***</span></span>
<span><span class="co">##        0.2751     </span></span>
<span><span class="co">##        0.3067     </span></span>
<span><span class="co">##        0.6690     </span></span>
<span><span class="co">##        &lt;0.001  ***</span></span>
<span><span class="co">##        0.6386     </span></span>
<span><span class="co">##        0.9560     </span></span>
<span><span class="co">##        0.1810     </span></span>
<span><span class="co">##        0.0141    *</span></span></code></pre>
<p>Suppose that we are interested in the effect of small versus regular
size classes, and in particular whether this effect varies across
schools in different areas. The coefficients on
<code>schoolksuburban:starksmall</code> and
<code>schoolkrural:starksmall</code> already give us the differences in
treatment effects between suburban schools versus urban schools and
between rural schools versus urban schools. The difference between these
coefficients gives us the difference in treatment effects between
suburban schools and rural schools. We can look at all three of these
contrasts using <code><a href="../reference/constraint_matrices.html">constrain_pairwise()</a></code> by setting the option
<code>with_zero = TRUE</code>:</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Wald_test.html">Wald_test</a></span><span class="op">(</span><span class="va">lm_urbanicity</span>, </span>
<span>          constraints <span class="op">=</span> <span class="fu"><a href="../reference/constraint_matrices.html">constrain_pairwise</a></span><span class="op">(</span><span class="st">":starksmall"</span>, reg_ex <span class="op">=</span> <span class="cn">TRUE</span>, with_zero <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>          vcov <span class="op">=</span> <span class="va">V_urbanicity</span>,</span>
<span>          tidy <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##                                            hypothesis test   Fstat df_num</span></span>
<span><span class="co">##                            schoolksuburban:starksmall  HTZ 0.22526      1</span></span>
<span><span class="co">##                               schoolkrural:starksmall  HTZ 0.00308      1</span></span>
<span><span class="co">##  schoolkrural:starksmall - schoolksuburban:starksmall  HTZ 0.36471      1</span></span>
<span><span class="co">##  df_denom p_val sig</span></span>
<span><span class="co">##      28.9 0.639    </span></span>
<span><span class="co">##      34.0 0.956    </span></span>
<span><span class="co">##      24.4 0.551</span></span></code></pre>
<p>Again, the results of the first two tests are identical to the
t-tests reported in <code><a href="../reference/coef_test.html">coef_test()</a></code>.</p>
</div>
<div class="section level2">
<h2 id="remark">Remark<a class="anchor" aria-label="anchor" href="#remark"></a>
</h2>
<p>All of the preceding examples were based on ordinary linear
regression models with clustered standard errors. However,
<code><a href="../reference/Wald_test.html">Wald_test()</a></code> and its helper functions all work identically
for all of the other models with supporting <code>clubSandwich</code>
methods, including <code><a href="https://rdrr.io/pkg/nlme/man/lme.html" class="external-link">nlme::lme()</a></code>, <code><a href="https://rdrr.io/pkg/nlme/man/gls.html" class="external-link">nlme::gls()</a></code>,
<code><a href="https://rdrr.io/pkg/lme4/man/lmer.html" class="external-link">lme4::lmer()</a></code>, <code><a href="https://wviechtb.github.io/metafor/reference/rma.uni.html" class="external-link">rma.uni()</a></code>,
<code><a href="https://wviechtb.github.io/metafor/reference/rma.mv.html" class="external-link">rma.mv()</a></code>, and <code><a href="https://rdrr.io/pkg/robumeta/man/robu.html" class="external-link">robu()</a></code>, among others.</p>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0" line-spacing="2">
<div id="ref-pustejovsky2018small" class="csl-entry">
Pustejovsky, J. E., &amp; Tipton, E. (2018). Small-<span>Sample</span>
<span>Methods</span> for <span>Cluster</span>-<span>Robust</span>
<span>Variance</span> <span>Estimation</span> and
<span>Hypothesis</span> <span>Testing</span> in <span>Fixed</span>
<span>Effects</span> <span>Models</span>. <em>Journal of Business &amp;
Economic Statistics</em>, <em>36</em>(4), 672â€“683. <a href="https://doi.org/10.1080/07350015.2016.1247004" class="external-link">https://doi.org/10.1080/07350015.2016.1247004</a>
</div>
<div id="ref-tipton2015small" class="csl-entry">
Tipton, E., &amp; Pustejovsky, J. E. (2015). Small-sample adjustments
for tests of moderators and model fit using robust variance estimation
in meta-regression. <em>Journal of Educational and Behavioral
Statistics</em>, <em>40</em>(6), 604â€“634. <a href="https://doi.org/10.3102/1076998615606099" class="external-link">https://doi.org/10.3102/1076998615606099</a>
</div>
</div>
</div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by James Pustejovsky.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
